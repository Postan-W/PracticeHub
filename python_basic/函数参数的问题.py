#一般函数接收用星号拆解的实参。星号拆解只是一种简便的传参方式，跟下面要讨论的可变参数没有关系，尽管二者都使用到了星号
def func1(a,b,c,d):
    print(a+b+c+d)

func1(*{"a":2,"b":3,"c":4,"d":5})#用*拆解字典就是分别把key作为实参传入函数。前提是key的数量与函数形参相同
func1(**{"a":2,"b":3,"c":4,"d":5})#**拆解字典就是以key为参数名value为参数值传入函数。前提是key与函数形参一致
# func1(**{"a":2,"b":3,"c":4,"f":5})#形参f不存在，所以报错
func1(*[5,6,7,8])#*拆解列表或元组直接将每个元素按顺序放到函数参数位置上。没有双星号的用法

#列表形式的可变数量参数函数
def fuc2(*args):#可变参数
   try:
       total = 0
       for i in range(len(args)):
           total += args[i]
       print(total)
   except:
       total = ""
       for i in range(len(args)):
           total += args[i]
       print(total)

# fuc2([1,2,3])一个位置代表一个参数放到args列表里去
fuc2(*[10,11,12])#这里的星号和可变参数的星号代表的意思是不同的，这里是拆解,等同于fuc2(10,11,12)
fuc2(*{"a":2,"b":3,"c":4,"d":5})#同上
fuc2(1,2,3,4)
# fuc2(1,2,3,4,h=10)不能指定参数名
#字典形式的可变数量参数函数
def fuc3(**args):
    print(args.keys())
    print(args.values())

# fuc3({"a":2,"b":3,"c":4,"d":5})直接这样调用显然是没明白可变参数是怎么操作的。实际上一个实参对应一个可变参数对象的一个元素
fuc3(**{"a":2,"b":3,"c":4,"d":5})
fuc3(a=2,b=3,c=4,d=5)#等同上句
# fuc3(a=2,b=3,c=4,d=5,7)#没有指定参数名就没有key，就会报错

#列表形式的和字典形式的一起使用
def fuc4(*args1,**args2):#列表型的在前字典型的在后，否则则报错
    print(args1)
    print(args2)

fuc4(1,2,3,4,a=10,b=11,c=12)#不能两种形式的参数穿插放置或者指定参数名的在前不指定的在后
fuc4(*[1,2,3],**{"a":2,"b":3,"c":4,"d":5})